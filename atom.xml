<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菜鸟の博客</title>
  
  <subtitle>点滴———记录美好生活。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kerwang99.top/"/>
  <updated>2019-06-23T03:25:49.417Z</updated>
  <id>http://kerwang99.top/</id>
  
  <author>
    <name>kerWang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STM32时钟树及SysTick配置</title>
    <link href="http://kerwang99.top/2019/06/27/STM32%E6%97%B6%E9%92%9F%E6%A0%91%E5%8F%8ASysTick%E9%85%8D%E7%BD%AE/"/>
    <id>http://kerwang99.top/2019/06/27/STM32时钟树及SysTick配置/</id>
    <published>2019-06-27T01:04:56.000Z</published>
    <updated>2019-06-23T03:25:49.417Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --><p>&#160; &#160; &#160; &#160; STM32F4的时钟树对于整个系通的运行和我们后面的学习起着非常重要的作用，当我学完GPIO，USART,中断。学到定时器时才发现时钟是我们不得不了解的一部分，因为在之前我学到定时器时按照流程，配置的定时器定时一直不是很准确。最后才发现原来是系统的时钟树配置的有误。下面我们将介绍一下时钟树和系统滴答定时器SysTick的配置。</p><a id="more"></a><h1 id="一、时钟树"><a href="#一、时钟树" class="headerlink" title="一、时钟树"></a>一、时钟树</h1><h2 id="1-时钟树的分析"><a href="#1-时钟树的分析" class="headerlink" title="1.时钟树的分析"></a>1.时钟树的分析</h2><p>&#160; &#160; &#160; &#160; STM32F4的系统时钟复杂很多，首先是时钟源有四个，它们分别是LSI:内部低速振荡器；HSI：内部高速振荡器；LSE：外部低速振荡器；HSE外部高速振荡器。下图是我们从《STM32F4XX中文参考手册》中截取的一部分，我们来做以分析。</p><p><img src="\images\时钟树\时钟树.png" alt></p><p>图中①处为 LSI:内部低速振荡器(32K) 只提供给看门狗和RTC。</p><p>图中②处为 HSI:内部高速振荡器(16M) 1.为系统提供时钟 2.为PLL提供时钟</p><p>图中③处为 LSE:外部低速振荡器(32.768k) 只提供给RTC模块</p><p>图中④处为 HSE:外部高速振荡器(4-26M) 1.经过分频为RTC提供时钟<br>2.为系统提供时钟（一般不直接用，频率太慢,经过锁相环倍频后用）<br>3.为PLL提供时钟</p><p>我这里使用的是正点原子的探索者开发板。查阅原理图可知。HSE用的是一个8M的晶振，所以这里HSE就为8MHZ。</p><p><img src="\images\时钟树\晶振.png" alt></p><p>&#160; &#160; &#160; &#160; 从时钟树图上看到，系统支持的最大频率为168Mhz，为了使系统运行的更高效，我们就将内核时钟配置为168MHZ。看图中⑤处，HSI为16MHZ，HSE为8MHz，他们经过M分频后进入锁相环，在经过N倍频，最后经过P分频成为SYSCLK（168M）.所以如果选用HSE最为系统的输出时钟那么SYSCLK=8/M<em>N/P=168;如果选用HSI作为系统时钟那么SYSCLK=16/M </em>N/P=168。选哪个时钟可以通过修改启动文件来选择，一般我们选用HSE。从以上分析可知我们只需要修改M、N、P三个值就可以使得系统时钟达到168MHZ。M、N、P三个值的修改位于《system_stm32f4XX.c》中。</p><p>&#160; &#160; &#160; &#160; 对于时钟树右边各个外设时钟的分析见下图。</p><p><img src="\images\时钟树\时钟树右半边.png" alt></p><h2 id="2-时钟树的配置"><a href="#2-时钟树的配置" class="headerlink" title="2.时钟树的配置"></a>2.时钟树的配置</h2><p>&#160; &#160; &#160; &#160; 为了更方便更快速的配置时钟树，我们就不去修改启动文件中的代码了。下面借鉴正点原子提供的代码来配置系统时钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统时钟初始化函数</span></span><br><span class="line"><span class="comment">//plln:主PLL倍频系数(PLL倍频),取值范围:64~432.</span></span><br><span class="line"><span class="comment">//pllm:主PLL和音频PLL分频系数(PLL之前的分频),取值范围:2~63.</span></span><br><span class="line"><span class="comment">//pllp:系统时钟的主PLL分频系数(PLL之后的分频),取值范围:2,4,6,8.(仅限这4个值!)</span></span><br><span class="line"><span class="comment">//pllq:USB/SDIO/随机数产生器等的主PLL分频系数(PLL之后的分频),取值范围:2~15.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stm32_Clock_Init</span><span class="params">(u32 plln,u32 pllm,u32 pllp,u32 pllq)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">RCC-&gt;CR|=<span class="number">0x00000001</span>;<span class="comment">//设置HISON,开启内部高速RC振荡</span></span><br><span class="line">RCC-&gt;CFGR=<span class="number">0x00000000</span>;<span class="comment">//CFGR清零 </span></span><br><span class="line">RCC-&gt;CR&amp;=<span class="number">0xFEF6FFFF</span>;<span class="comment">//HSEON,CSSON,PLLON清零 </span></span><br><span class="line">RCC-&gt;PLLCFGR=<span class="number">0x24003010</span>;<span class="comment">//PLLCFGR恢复复位值 </span></span><br><span class="line">RCC-&gt;CR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">18</span>);<span class="comment">//HSEBYP清零,外部晶振不旁路</span></span><br><span class="line">RCC-&gt;CIR=<span class="number">0x00000000</span>;<span class="comment">//禁止RCC时钟中断 </span></span><br><span class="line">Sys_Clock_Set(plln,pllm,pllp,pllq);<span class="comment">//设置时钟</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时钟设置函数</span></span><br><span class="line"><span class="comment">//Fvco=Fs*(plln/pllm);   </span></span><br><span class="line"><span class="comment">//Fsys=Fvco/pllp=Fs*(plln/(pllm*pllp));</span></span><br><span class="line"><span class="comment">//Fusb=Fvco/pllq=Fs*(plln/(pllm*pllq));</span></span><br><span class="line"><span class="comment">//Fvco:VCO频率</span></span><br><span class="line"><span class="comment">//Fsys:系统时钟频率</span></span><br><span class="line"><span class="comment">//Fusb:USB,SDIO,RNG等的时钟频率</span></span><br><span class="line"><span class="comment">//Fs:PLL输入时钟频率,可以是HSI,HSE等. </span></span><br><span class="line"><span class="comment">//plln:主PLL倍频系数(PLL倍频),取值范围:64~432.</span></span><br><span class="line"><span class="comment">//pllm:主PLL和音频PLL分频系数(PLL之前的分频),取值范围:2~63.</span></span><br><span class="line"><span class="comment">//pllp:系统时钟的主PLL分频系数(PLL之后的分频),取值范围:2,4,6,8.(仅限这4个值!)</span></span><br><span class="line"><span class="comment">//pllq:USB/SDIO/随机数产生器等的主PLL分频系数(PLL之后的分频),取值范围:2~15.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//外部晶振为8M的时候,推荐值:plln=336,pllm=8,pllp=2,pllq=7.</span></span><br><span class="line"><span class="comment">//得到:Fvco=8*(336/8)=336Mhz</span></span><br><span class="line"><span class="comment">//     Fsys=336/2=168Mhz</span></span><br><span class="line"><span class="comment">//     Fusb=336/7=48Mhz</span></span><br><span class="line"><span class="comment">//返回值:0,成功;1,失败。</span></span><br><span class="line"></span><br><span class="line"><span class="function">u8 <span class="title">Sys_Clock_Set</span><span class="params">(u32 plln,u32 pllm,u32 pllp,u32 pllq)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">u16 retry=<span class="number">0</span>;</span><br><span class="line">u8 status=<span class="number">0</span>;</span><br><span class="line">RCC-&gt;CR|=<span class="number">1</span>&lt;&lt;<span class="number">16</span>;<span class="comment">//HSE 开启 </span></span><br><span class="line"><span class="keyword">while</span>(((RCC-&gt;CR&amp;(<span class="number">1</span>&lt;&lt;<span class="number">17</span>))==<span class="number">0</span>)&amp;&amp;(retry&lt;<span class="number">0X1FFF</span>))retry++;<span class="comment">//等待HSE RDY</span></span><br><span class="line"><span class="keyword">if</span>(retry==<span class="number">0X1FFF</span>)status=<span class="number">1</span>;<span class="comment">//HSE无法就绪</span></span><br><span class="line"><span class="keyword">else</span>   </span><br><span class="line">&#123;</span><br><span class="line">RCC-&gt;APB1ENR|=<span class="number">1</span>&lt;&lt;<span class="number">28</span>;<span class="comment">//电源接口时钟使能</span></span><br><span class="line">PWR-&gt;CR|=<span class="number">3</span>&lt;&lt;<span class="number">14</span>; <span class="comment">//高性能模式,时钟可到168Mhz</span></span><br><span class="line">RCC-&gt;CFGR|=(<span class="number">0</span>&lt;&lt;<span class="number">4</span>)|(<span class="number">5</span>&lt;&lt;<span class="number">10</span>)|(<span class="number">4</span>&lt;&lt;<span class="number">13</span>);<span class="comment">//HCLK 不分频;APB1 4分频;APB2 2分频. </span></span><br><span class="line">RCC-&gt;CR&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">24</span>);<span class="comment">//关闭主PLL</span></span><br><span class="line">RCC-&gt;PLLCFGR=pllm|(plln&lt;&lt;<span class="number">6</span>)|(((pllp&gt;&gt;<span class="number">1</span>)<span class="number">-1</span>)&lt;&lt;<span class="number">16</span>)|(pllq&lt;&lt;<span class="number">24</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">22</span>);<span class="comment">//配置主PLL,PLL时钟源来自HSE</span></span><br><span class="line">RCC-&gt;CR|=<span class="number">1</span>&lt;&lt;<span class="number">24</span>;<span class="comment">//打开主PLL</span></span><br><span class="line"><span class="keyword">while</span>((RCC-&gt;CR&amp;(<span class="number">1</span>&lt;&lt;<span class="number">25</span>))==<span class="number">0</span>);<span class="comment">//等待PLL准备好 </span></span><br><span class="line">FLASH-&gt;ACR|=<span class="number">1</span>&lt;&lt;<span class="number">8</span>;<span class="comment">//指令预取使能.</span></span><br><span class="line">FLASH-&gt;ACR|=<span class="number">1</span>&lt;&lt;<span class="number">9</span>;<span class="comment">//指令cache使能.</span></span><br><span class="line">FLASH-&gt;ACR|=<span class="number">1</span>&lt;&lt;<span class="number">10</span>;<span class="comment">//数据cache使能.</span></span><br><span class="line">FLASH-&gt;ACR|=<span class="number">5</span>&lt;&lt;<span class="number">0</span>;<span class="comment">//5个CPU等待周期. </span></span><br><span class="line">RCC-&gt;CFGR&amp;=~(<span class="number">3</span>&lt;&lt;<span class="number">0</span>);<span class="comment">//清零</span></span><br><span class="line">RCC-&gt;CFGR|=<span class="number">2</span>&lt;&lt;<span class="number">0</span>;<span class="comment">//选择主PLL作为系统时钟 </span></span><br><span class="line"><span class="keyword">while</span>((RCC-&gt;CFGR&amp;(<span class="number">3</span>&lt;&lt;<span class="number">2</span>))!=(<span class="number">2</span>&lt;&lt;<span class="number">2</span>));<span class="comment">//等待主PLL作为系统时钟成功. </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这两个函数添加到工程中，只需要在main函数中调用<code>u8 Sys_Clock_Set(u32 plln,u32 pllm,u32 pllp,u32 pllq)</code> 即可。示例如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">Stm32_Clock_Init(<span class="number">336</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">7</span>);<span class="comment">//设置时钟,168Mhz</span></span><br><span class="line">delay_init(<span class="number">168</span>);<span class="comment">//初始化延时函数</span></span><br><span class="line">LED_Init();<span class="comment">//初始化LED时钟  </span></span><br><span class="line">BEEP_Init();         <span class="comment">//初始化蜂鸣器端口</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED0=<span class="number">0</span>;</span><br><span class="line">BEEP=<span class="number">0</span>;  </span><br><span class="line">delay_ms(<span class="number">300</span>);</span><br><span class="line">LED0=<span class="number">1</span>;  </span><br><span class="line">BEEP=<span class="number">1</span>;  </span><br><span class="line">delay_ms(<span class="number">300</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、SysTick系统滴答定时器"><a href="#二、SysTick系统滴答定时器" class="headerlink" title="二、SysTick系统滴答定时器"></a>二、SysTick系统滴答定时器</h1><h2 id="1-SysTick的分析"><a href="#1-SysTick的分析" class="headerlink" title="1.SysTick的分析"></a>1.SysTick的分析</h2><p>&#160; &#160; &#160; &#160; 系统滴答定时器主要是为操作系统提供一个心跳节拍，他也可以作为一个通用定时器来定时，做延时处理。它属于NVIC的一部分，且可以产生中断。systick是一个24位向下计数的计数器，可以使用处理器时钟或参考时钟。</p><p><img src="\images\时钟树\批注 2019-06-23 105436.png" alt></p><p>&#160; &#160; &#160; &#160; systick可以选择两个时钟源，一个是参考时钟，是21MHZ，查看时钟树得知为系统时钟的八分频；另一个为处理器时钟，即168MHZ。一般选用21M时钟作为时钟源。因为可以计时更长。</p><p>&#160; &#160; &#160; &#160; systick是一个24位向下计数的计数器，计数值从0减到1时会产生一个中断，或者一个标志位，用来告诉你定时时间到。当计数值减到0后会自动的从重装载值寄存器中把要计数的值移到计数器中，继续递减到0产生中断依次循环。上面所说的选择时钟源，计数器使能，产生中断与否都通过控制和状态寄存器（CTRL）来控制。</p><h2 id="2-SysTick配置"><a href="#2-SysTick配置" class="headerlink" title="2.SysTick配置"></a>2.SysTick配置</h2><p>&#160; &#160; &#160; &#160; 配置之前先看一下有关寄存器的说明</p><p><img src="\images\时钟树\批注 2019-06-23 110723.png" alt></p><p>从上面CTRL寄存器的16位看到，当计数时间到是该位为自动置1，可以通过查询该位是否为1来判断计数时间是否到达，这种方式称为查询方式。还有一种就是根据中断判断计时是否到达。</p><p>配置流程</p><p>① 关闭定时器</p><p>② 选择时钟源</p><p>③ 设置重装载值</p><p>④清空当前计数器的值</p><p>⑤选择是否需要中断</p><p>⑥开启定时器</p><p>⑦等待定时时间到</p><p>⑧关闭定时器</p><p>==<strong>注意：systick是一个24位定时器，计时的最大数值为0XFFFFFF=16777215D个数，</strong>==</p><p>==<strong>如果系统时钟选择为21MHZ的话最大计时16777215/21000=798ms。定时时长不要超过该数值</strong>==</p><p>配置实例代码（查询方式，无中断）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_ms</span><span class="params">(u32 nms)</span>            <span class="comment">/*最多计时798ms*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SysTick-&gt;CTRL&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//SYSTICK使用外部参考时钟源 21MHZ</span></span><br><span class="line">    SysTick-&gt;LOAD=(u32)nms*<span class="number">21000</span><span class="number">-1</span>;</span><br><span class="line">SysTick-&gt;VAL =<span class="number">0x00</span>;           <span class="comment">//清空计数器</span></span><br><span class="line">SysTick-&gt;CTRL=<span class="number">0x01</span> ;          <span class="comment">//开始倒数 </span></span><br><span class="line">    <span class="keyword">while</span>(!(SysTick-&gt;CTRL&amp;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)));<span class="comment">//等待时间到达    </span></span><br><span class="line">SysTick-&gt;CTRL=<span class="number">0x00</span>;       <span class="comment">//关闭计数器</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0X00</span>;       <span class="comment">//清空计数器  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_us</span><span class="params">(u32 nus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SysTick-&gt;CTRL&amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//SYSTICK使用外部时钟源</span></span><br><span class="line">    SysTick-&gt;LOAD=(u32)nus*<span class="number">21</span><span class="number">-1</span>;</span><br><span class="line">SysTick-&gt;VAL =<span class="number">0x00</span>;           <span class="comment">//清空计数器</span></span><br><span class="line">SysTick-&gt;CTRL=<span class="number">0x01</span> ;          <span class="comment">//开始倒数 </span></span><br><span class="line">    <span class="keyword">while</span>(!(SysTick-&gt;CTRL&amp;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)));<span class="comment">//等待时间到达    </span></span><br><span class="line">SysTick-&gt;CTRL=<span class="number">0x00</span>;       <span class="comment">//关闭计数器</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0X00</span>;       <span class="comment">//清空计数器  </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160; STM32F4的时钟树对于整个系通的运行和我们后面的学习起着非常重要的作用，当我学完GPIO，USART,中断。学到定时器时才发现时钟是我们不得不了解的一部分，因为在之前我学到定时器时按照流程，配置的定时器定时一直不是很准确。最后才发现原来是系统的时钟树配置的有误。下面我们将介绍一下时钟树和系统滴答定时器SysTick的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="STM32" scheme="http://kerwang99.top/categories/STM32/"/>
    
    
      <category term="STM32" scheme="http://kerwang99.top/tags/STM32/"/>
    
      <category term="定时器" scheme="http://kerwang99.top/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>EXTI外部中断配置流程</title>
    <link href="http://kerwang99.top/2019/06/24/%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
    <id>http://kerwang99.top/2019/06/24/外部中断配置流程/</id>
    <published>2019-06-24T11:02:01.000Z</published>
    <updated>2019-06-24T12:09:30.838Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --><p>&#160; &#160; &#160; &#160; 外部中断/事件控制器包含多达 23 个用于产生事件/中断请求的边沿检测器。每根输入线都可<br>单独进行配置，以选择类型（中断或事件）和相应的触发事件（上升沿触发、下降沿触发或<br>边沿触发）。每根输入线还可单独屏蔽。挂起寄存器用于保持中断请求的状态线。</p><a id="more"></a><p>&#160; &#160; &#160; &#160; 第一步：先对需要中断的IO口初始化</p><p>&#160; &#160; &#160; &#160; 第二步：根据外部中断IO口的映射图找出是哪个中断</p><p><img src="\images\NVIC\中断IO映射关系.png" alt></p><p>&#160; &#160; &#160; &#160; 比如：我需要配置按键中断，某个按键连接PE2，根据上面这张图的映射关系可以找出中断为EXTI2.</p><p>&#160; &#160; &#160; &#160; 第三步：配置SYSCFG重映射寄存器</p><p>&#160; &#160; &#160; &#160; ①打开SYSCFG的时钟，该时钟位于APB2总线上。</p><p><img src="\images\NVIC\时钟.png" alt></p><p>&#160; &#160; &#160; &#160; ②配置SYSCFG的外部中断配置寄存器 SYSCFG-&gt;EXTIRx</p><p><img src="\images\NVIC\exticr1.png" alt></p><p>&#160; &#160; &#160; &#160; 比如：我需要配置按键中断，某个按键连接PE2，由上面得知该中断源为EXTI2。根据上图可以配置SYSCFG-&gt;EXTIR1寄存器的8-12位，配置为0100.</p><p><strong>这里需要注意的是，在keil中将EXTICR1——EXTICR4定义为EXTICR[0-3]</strong></p><p>&#160; &#160; &#160; &#160; 第四步：配置EXTI-&gt;IMR寄存器，开放来自那个口的中断源</p><p><img src="\images\NVIC\IMR.png" alt></p><p>&#160; &#160; &#160; &#160; 比如：我需要配置按键中断，某个按键连接PE2，我需要将IMR寄存器的第2位置1.</p><p>&#160; &#160; &#160; &#160; 第五步：选择中断触发方式 上升沿触还是下降沿触发。上升沿触发寄存器是RTSR；下降沿触发寄存器是FTSR。</p><p>例如：某个按键按下时低电平，连接PE2。则需要将EXTI-&gt;FTSR寄存器的第二位置1；</p><p>&#160; &#160; &#160; &#160; 第六步：设置中断分组，抢占优先级个响应优先级</p><p>&#160; &#160; &#160; &#160; 第七步：编写中断服务函数，记得中断执行结束后清除中断标志。</p><p><strong>外部中断清除中断标志：向EXTI—&gt;PR寄存器相应的位写1</strong></p><hr><p>&#160; &#160; &#160; &#160;</p><p>&#160; &#160; &#160; &#160; <strong><em>示例：</em></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">KEY0-KEY2  按下低电平   PE4-PE2  EXTI4,EXTI3,EXTI2   下降沿触发</span></span><br><span class="line"><span class="comment">KEY_UP     按下高电平   PA0      EXTI0               上升沿触发  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exti_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 val1,val2,val3,val4;</span><br><span class="line">key_init();</span><br><span class="line">RCC-&gt;APB2ENR|=<span class="number">1</span>&lt;&lt;<span class="number">14</span>;  <span class="comment">//使能SYSCFG时钟 </span></span><br><span class="line"><span class="comment">/**************KEY2-EXTI2*********************/</span></span><br><span class="line">SYSCFG-&gt;EXTICR[<span class="number">0</span>] &amp;=~(<span class="number">0xF</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">SYSCFG-&gt;EXTICR[<span class="number">0</span>] |=(<span class="number">0X4</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">EXTI-&gt;IMR |=(<span class="number">0X1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">EXTI-&gt;FTSR |=(<span class="number">0X1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line"><span class="comment">/*******************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************KEY1-EXTI3*********************/</span></span><br><span class="line">SYSCFG-&gt;EXTICR[<span class="number">0</span>]&amp;=~(<span class="number">0XF</span>&lt;&lt;<span class="number">12</span>); <span class="comment">//清除原来的设置</span></span><br><span class="line">SYSCFG-&gt;EXTICR[<span class="number">0</span>]|=(<span class="number">0X1</span>&lt;&lt;<span class="number">14</span>);  </span><br><span class="line">EXTI-&gt;IMR |=(<span class="number">0X1</span>&lt;&lt;<span class="number">3</span>);           <span class="comment">//开启来自该IO口的中断</span></span><br><span class="line">EXTI-&gt;FTSR |=(<span class="number">0X1</span>&lt;&lt;<span class="number">3</span>);          <span class="comment">//下降沿触发</span></span><br><span class="line"><span class="comment">/*******************************************/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**************KEY0-EXTI4*********************/</span> </span><br><span class="line">  SYSCFG-&gt;EXTICR[<span class="number">0</span>]&amp;=~(<span class="number">0XF</span>);</span><br><span class="line">  EXTI -&gt;IMR |=(<span class="number">0X1</span>);</span><br><span class="line">EXTI -&gt;RTSR |=(<span class="number">0X1</span>);</span><br><span class="line"><span class="comment">/*******************************************/</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">/**************KEY0-EXTI4*********************/</span>  </span><br><span class="line">SYSCFG-&gt;EXTICR[<span class="number">1</span>]&amp;=~(<span class="number">0xF</span>);<span class="comment">//清除原来设置！！！</span></span><br><span class="line">SYSCFG-&gt;EXTICR[<span class="number">1</span>]|=<span class="number">4</span>&lt;&lt;<span class="number">0</span>;<span class="comment">//EXTI.BITx映射到GPIOx.BITx </span></span><br><span class="line">EXTI-&gt;IMR|=<span class="number">1</span>&lt;&lt;<span class="number">4</span>;<span class="comment">//开启line BITx上的中断(如果要禁止中断，则反操作即可)</span></span><br><span class="line">EXTI-&gt;FTSR|=<span class="number">1</span>&lt;&lt;<span class="number">4</span>;<span class="comment">//line BITx上事件下降沿触发</span></span><br><span class="line"><span class="comment">/*******************************************/</span></span><br><span class="line"></span><br><span class="line">    NVIC_SetPriorityGrouping(<span class="number">7</span><span class="number">-5</span>);  <span class="comment">//分组2</span></span><br><span class="line"></span><br><span class="line">val1=NVIC_EncodePriority (<span class="number">7</span><span class="number">-5</span>,<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">NVIC_SetPriority(EXTI2_IRQn,val1);      <span class="comment">//抢占优先级3，响应优先级2</span></span><br><span class="line"></span><br><span class="line">val2=NVIC_EncodePriority (<span class="number">7</span><span class="number">-5</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">NVIC_SetPriority(EXTI3_IRQn,val2);      <span class="comment">//抢占优先级2，响应优先级2</span></span><br><span class="line"></span><br><span class="line">val3=NVIC_EncodePriority (<span class="number">7</span><span class="number">-5</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">NVIC_SetPriority(EXTI4_IRQn,val3);      <span class="comment">//抢占优先级1，响应优先级2</span></span><br><span class="line"></span><br><span class="line">val4=NVIC_EncodePriority (<span class="number">7</span><span class="number">-5</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">NVIC_SetPriority(EXTI0_IRQn,val4);      <span class="comment">//抢占优先级0，响应优先级2</span></span><br><span class="line"></span><br><span class="line">NVIC_EnableIRQ(EXTI2_IRQn);</span><br><span class="line">NVIC_EnableIRQ(EXTI3_IRQn);</span><br><span class="line">NVIC_EnableIRQ(EXTI4_IRQn);</span><br><span class="line">NVIC_EnableIRQ(EXTI0_IRQn); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI4_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KEY0==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED1_ON ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EXTI-&gt;PR |=(<span class="number">0x1</span>&lt;&lt;<span class="number">4</span>);    <span class="comment">//清除中断标志</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI3_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED1_OFF ;</span><br><span class="line">&#125;</span><br><span class="line">EXTI-&gt;PR |=(<span class="number">0X1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED0_ON ;</span><br><span class="line">&#125;</span><br><span class="line">EXTI-&gt;PR |=(<span class="number">0x1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span>(WK_UP==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED0_OFF ;</span><br><span class="line">&#125;</span><br><span class="line">EXTI -&gt;PR |=(<span class="number">0X1</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160; 外部中断/事件控制器包含多达 23 个用于产生事件/中断请求的边沿检测器。每根输入线都可&lt;br&gt;单独进行配置，以选择类型（中断或事件）和相应的触发事件（上升沿触发、下降沿触发或&lt;br&gt;边沿触发）。每根输入线还可单独屏蔽。挂起寄存器用于保持中断请求的状态线。&lt;/p&gt;
    
    </summary>
    
      <category term="STM32" scheme="http://kerwang99.top/categories/STM32/"/>
    
    
      <category term="STM32" scheme="http://kerwang99.top/tags/STM32/"/>
    
      <category term="中断" scheme="http://kerwang99.top/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>STM32中断管理</title>
    <link href="http://kerwang99.top/2019/06/22/STM32%E4%B8%AD%E6%96%AD%E7%AE%A1%E7%90%86/"/>
    <id>http://kerwang99.top/2019/06/22/STM32中断管理/</id>
    <published>2019-06-22T07:57:31.000Z</published>
    <updated>2019-06-22T09:12:26.996Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --><blockquote><p>&#160; &#160; &#160; &#160; CM4内核支持256个中断，其中包含了16个内核中断和240个外部中断，并且具有256级的可编程中断设置。这么多中断是怎么管理的呢?下面我们一探究竟。</p></blockquote><a id="more"></a><h1 id="1-NVIC-初识"><a href="#1-NVIC-初识" class="headerlink" title="1.NVIC 初识"></a>1.NVIC 初识</h1><p>&#160; &#160; &#160; &#160; 在cortex—m4中有一个和内核紧密耦合的部件叫做嵌套向量中断控制器（NVIC），该东西管着所有的中断。NVIC将所有的中断进行分组，一共分为7个组，每个组又有抢占优先级和响应优先级。</p><p>&#160; &#160; &#160; &#160;中断入口最多有256个，中断嵌套层数最多只有128层。只有抢占优先级具有嵌套功能。</p><p><img src="\images\NVIC\批注 2019-06-22 163132.png" alt></p><p>&#160; &#160; &#160; &#160; 分组值(不是组编号)为7时,抢占优先级占7bit，可以中断嵌套128层。</p><p>​</p><p>&#160; &#160; &#160; &#160; <strong>抢占优先级和响应优先级的区别：</strong></p><p>&#160; &#160; &#160; &#160;</p><p>&#160; &#160; &#160; &#160; 抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。</p><p>&#160; &#160; &#160; &#160;抢占优先级和响应优先级相同时，谁先发生谁先响应。</p><p>&#160; &#160; &#160; &#160;根据以上可以得到如下表格</p><p><img src="\images\NVIC\中断分组.png" alt></p><p>SCR-&gt;AIRCI为分组值，可见分组值=7-组编号。</p><p>==<strong>特别说明</strong>==</p><p><strong>一般情况下，系统代码执行过程中，只设置一次中断优先级分组，比如分组2，设置好分组之后一般不会再改变分组。随意改变分组会导致中断管理混乱，程序出现意想不到的执行结果。</strong></p><h1 id="2-NVIC配置"><a href="#2-NVIC配置" class="headerlink" title="2.NVIC配置"></a>2.NVIC配置</h1><p>通过响应的函数可以快速配置</p><p>NVIC_SetPriorityGrouping（） //设置分组值<br>NVIC_GetPriorityGrouping (void) //此函数用于读取优先级分组<br>NVIC_EnableIRQ<br>NVIC_DisableIRQ<br>NVIC_ClearPendingIRQ(IRQn_Type IRQn) //清除中断标志位<br>NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority) //设置中断优先级<br>NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)<br>//设置使用给定的优先级组对中断的优先级进行编码，抢先优先级值和子优先级值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_SetPriorityGrouping</span><span class="params">(<span class="keyword">uint32_t</span> PriorityGroup)</span></span></span><br><span class="line">函数功能： 设置分组值</span><br><span class="line">函数形参： 分组结果——&gt; <span class="number">7</span>-组编号</span><br><span class="line">示    例： 选用组编号为<span class="number">3</span>号</span><br><span class="line">NVIC_SetPriorityGrouping（<span class="number">7</span><span class="number">-3</span>）</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u32 <span class="title">NVIC_EncodePriority</span> <span class="params">(<span class="keyword">uint32_t</span> PriorityGroup, <span class="keyword">uint32_t</span> PreemptPriority, <span class="keyword">uint32_t</span> SubPriority)</span> </span></span><br><span class="line">函数功能：合成抢占优先级和响应优先级以及分组。</span><br><span class="line">函数形参： PriorityGroup       <span class="number">7</span>-组编号</span><br><span class="line">          PreemptPriority     抢占优先级</span><br><span class="line">          SubPriority         响应优先级</span><br><span class="line">函数返回值：一个<span class="number">32</span>位的最终结果</span><br><span class="line">函数目的： 将这些情况合成起来成为一个最终的优先级结果</span><br><span class="line">示    例：选用组编号为<span class="number">3</span>号；抢占优先级：<span class="number">2</span>；响应优先级：<span class="number">3</span></span><br><span class="line"></span><br><span class="line"> val=NVIC_EncodePriority (<span class="number">7</span><span class="number">-3</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_SetPriority</span><span class="params">(IRQn_Type IRQn, <span class="keyword">uint32_t</span> priority)</span>  </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line">函数功能：设置某个中断的优先级</span><br><span class="line">函数形参：IRQn：哪一个中断；</span><br><span class="line">         priority：合成的优先级的结果，结果来自上一个函数</span><br><span class="line">示例：SysTick_IRQn中断</span><br><span class="line">         NVIC_SetPriority（SysTick_IRQn， val）；</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NVIC_EnableIRQ</span><span class="params">(IRQn_Type IRQn)</span></span></span><br><span class="line">函数功能：使能哪一个中断</span><br><span class="line">示    例：NVIC_EnableIRQ（SysTick_IRQn）；</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160; CM4内核支持256个中断，其中包含了16个内核中断和240个外部中断，并且具有256级的可编程中断设置。这么多中断是怎么管理的呢?下面我们一探究竟。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="STM32" scheme="http://kerwang99.top/categories/STM32/"/>
    
    
      <category term="NVIC" scheme="http://kerwang99.top/tags/NVIC/"/>
    
      <category term="STM32" scheme="http://kerwang99.top/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>STM32串口通信（UART）</title>
    <link href="http://kerwang99.top/2019/06/02/STM32%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/"/>
    <id>http://kerwang99.top/2019/06/02/STM32串口通信/</id>
    <published>2019-06-02T02:27:44.000Z</published>
    <updated>2019-06-22T04:15:27.940Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --><hr><blockquote><p>&#160; &#160; &#160; &#160; USART作为两个设备之间的一种通信协议，支持同步和异步两种通信方式。同步的时候两个设备需要共用同一个时钟，需要连接时钟线。异步的时候不用时钟连接线，通信双方按照设定好的波特率发送和接受数据即可。这里主要介绍一下UART异步通信方式。</p></blockquote><a id="more"></a><h1 id="1，UART框图的分析"><a href="#1，UART框图的分析" class="headerlink" title="1，UART框图的分析"></a>1，UART框图的分析</h1><p>&#160; &#160; &#160; &#160; 在正式介绍配置流程之前，我们先简单的分析一下uart通信过程的整个流程。下图是从《STM32F4XX中文参考手册》中截取的UART工作的原理图。</p><p><img src="\images\uart\批注 2019-06-02 104803.png" alt></p><h2 id="（1）数据的发送"><a href="#（1）数据的发送" class="headerlink" title="（1）数据的发送"></a>（1）数据的发送</h2><p>&#160; &#160; &#160; &#160; 首先发送的数据送到发送数据寄存器TDR中，发送数据寄存器等到发送数据移位寄存器为空时，自动把要发送的数据从TDR中转移到发送移位寄存器中。发送移位寄存器通过TX引脚将数据一位一位的发送出去。而发送移位寄存器又受发送控制寄存器的控制。从图中可以看出，发送控制寄存器需要配置下面的波特率和CR1中的TE位（即：发送时能位），其他的先不用管，有关波特率的配置下面再讲。</p><h2 id="（2）数据的接受"><a href="#（2）数据的接受" class="headerlink" title="（2）数据的接受"></a>（2）数据的接受</h2><p>&#160; &#160; &#160; &#160; 数据的接收和发送基本上一样。首先外设通过RX引脚向MCU发送数据，RX引脚收到数据后将数据送到接受移位寄存中，然后通过接受移位寄存器一位一位的将数据送到接收数据寄存器RDR中。我们想要获取接收到的数据只需要读RDR寄存器即可。同理，接收移位寄存器也受下面的接受控制器控制，这里只需要使能接受控制器和配好波特率即可。</p><h2 id="（3）波特率de分析"><a href="#（3）波特率de分析" class="headerlink" title="（3）波特率de分析"></a>（3）波特率de分析</h2><p>&#160; &#160; &#160; &#160; 我们将上图中的波特率控制部分放大。</p><p><img src="\images\uart\批注 2019-06-02 111301.png" alt></p><p>&#160; &#160; &#160; &#160; 先从下面f~PCLKx(x=1,2)~这里看起，f~PCLKx~表示我们UART工作时的时钟，UART有6个每个的工作时钟不一样，我们可以通过参考手册查出每个UART的工作时钟，</p><p><img src="\images\uart\批注 2019-06-02 112915.png" alt></p><p>&#160; &#160; &#160; &#160; 可以看到UART1时钟线连在APB2总线上，工作时钟为90MHZ。我们从图上在向上走，看到f~PCLKx~/usartdiv在向左走将刚才得到的数/[8x(2-OVER8)]后就得到波特率了。波特率在送到发送控制器和接受控制器就可以了。</p><p>&#160; &#160; &#160; &#160; 上面计算波特率公式中，我们已知的是波特率、f~PCLKx~和OVER8，所以我们只需要计算出usartdiv，将这个数值写入到USART_BRR寄存器中即可。</p><p>&#160; &#160; &#160; &#160; 这里的OVER8称为过采样频率<img src="\images\uart\批注 2019-06-02 113918.png" alt></p><center>一般设置成0，即16倍过采样。</center><font color="#FF0000">usartdiv=(float) f~PCLKx~ / (bound x 8 x (2-OVER8)); </font><font color="#FF0000">usartdiv由整数部分DIV_mantissa和小数部分DIV_fraction组成，</font><p><img src="\images\uart\批注 2019-06-02 114705.png" alt></p><font color="#FF0000">​ DIV_mantissa=usartdiv; 整数由usartdiv转换即可 float-——&gt;int</font><p><font color="#FF0000">​ DIV_fraction=((usartdiv - DIV_mantissa)*8)/(2-OVER8); 得到小数部分，</font> 该公式由UART框图下面给出了。</p><p>算出整数部分和小数部分后，把整数部分左移4位加上小数部分，把该数填入到USART_BRR寄存器即可。</p><p>&#160; &#160; &#160; &#160; ==<strong><em>由上面分析可知，整个波特率的配置只需要配置好OVER8，和USART_BRR寄存器。USART_BRR寄存器由整数和小数组成，该数是可以计算出的。</em></strong>==</p><p>分析到这里就结束了，下面用讲讲UART配置的一般步骤。</p><h1 id="2，UART配置的步骤"><a href="#2，UART配置的步骤" class="headerlink" title="2，UART配置的步骤"></a>2，UART配置的步骤</h1><h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="(1) 初始化"></a>(1) 初始化</h2><p>&#160; &#160; &#160; &#160; ①初始化GPIO口，查找原理图找出UART的发送引脚和接受引脚连接在哪个哪个IO口，就初始化哪个IO口</p><p>&#160; &#160; &#160; &#160; 1.开时钟</p><p>&#160; &#160; &#160; &#160; 2.选择复用</p><p>&#160; &#160; &#160; &#160; 3.选择开漏输出、输出速度</p><p>&#160; &#160; &#160; &#160; 4.复用为UART</p><p>&#160; &#160; &#160; &#160; ②初始化UART</p><p>&#160; &#160; &#160; &#160; 1.开时钟</p><p>&#160; &#160; &#160; &#160; 2.配波特率</p><p>&#160; &#160; &#160; &#160; 3.设置数据位长度、有无奇偶校验、停止位长度</p><p>&#160; &#160; &#160; &#160; 4.接受和发送使能</p><h2 id="（2）编写发送-接受一个字节的函数"><a href="#（2）编写发送-接受一个字节的函数" class="headerlink" title="（2）编写发送/接受一个字节的函数"></a>（2）编写发送/接受一个字节的函数</h2><h2 id="（3）编写发送-接受字符串的函数"><a href="#（3）编写发送-接受字符串的函数" class="headerlink" title="（3）编写发送/接受字符串的函数"></a>（3）编写发送/接受字符串的函数</h2><h1 id="3，示例代码"><a href="#3，示例代码" class="headerlink" title="3，示例代码"></a>3，示例代码</h1><p>&#160; &#160; &#160; &#160; UART初始化函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uast_init</span><span class="params">(<span class="keyword">int</span> bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">float</span> usartdiv=<span class="number">0</span>,div_fraction=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> div_mantissa=<span class="number">0</span>;</span><br><span class="line">RCC -&gt;AHB1ENR |=<span class="number">1</span>;    <span class="comment">//GPIO口使能</span></span><br><span class="line">GPIOA -&gt;MODER &amp;=~(<span class="number">0XF</span>&lt;&lt;<span class="number">9</span>*<span class="number">2</span>);</span><br><span class="line">GPIOA -&gt;MODER |=(<span class="number">0XA</span>&lt;&lt;<span class="number">18</span>);<span class="comment">//选择为复用功能</span></span><br><span class="line">GPIOA -&gt;OTYPER |=(<span class="number">0x3</span>&lt;&lt;<span class="number">9</span>);<span class="comment">//开漏输出    </span></span><br><span class="line">    </span><br><span class="line">GPIOA -&gt;OSPEEDR &amp;=~(<span class="number">0XF</span>&lt;&lt;<span class="number">18</span>);</span><br><span class="line">GPIOA -&gt;OSPEEDR |=(<span class="number">0xA</span>&lt;&lt;<span class="number">18</span>); <span class="comment">//50MHZ</span></span><br><span class="line">    <span class="comment">/*在KEIL中定义了把复用功能低位寄存器 (GPIOx_AFRL)定义成AFR[0] </span></span><br><span class="line"><span class="comment">                          把复用功能高位寄存器 (GPIOx_AFRH)定义成AFR[1]    */</span></span><br><span class="line">GPIOA -&gt;AFR[<span class="number">1</span>] &amp;=~(<span class="number">0XFF</span>&lt;&lt;<span class="number">4</span>);   <span class="comment">//这里把复用功能寄存器AFR分为低寄存器和高寄存器组ARF[0],ARF[1]</span></span><br><span class="line">GPIOA -&gt;AFR[<span class="number">1</span>] |=(<span class="number">0X77</span>&lt;&lt;<span class="number">4</span>);  <span class="comment">//复用为USART1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RCC-&gt;APB2ENR |=(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);    <span class="comment">//开启uart时钟</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************计算波特率******************/</span></span><br><span class="line">usartdiv=(<span class="keyword">float</span>)<span class="number">84000000</span>/(bound*<span class="number">8</span>*(<span class="number">2</span><span class="number">-0</span>));</span><br><span class="line">div_mantissa=usartdiv;   <span class="comment">//int&lt;--float</span></span><br><span class="line">div_fraction=((usartdiv-div_mantissa)*<span class="number">8</span>)/(<span class="number">2</span><span class="number">-0</span>);  <span class="comment">//算小数部分</span></span><br><span class="line">USART1 -&gt;BRR =(div_mantissa&lt;&lt;<span class="number">4</span>)+div_fraction;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">USART1-&gt;CR2 &amp;=~(<span class="number">0X3</span>&lt;&lt;<span class="number">12</span>);   <span class="comment">//1个停止位</span></span><br><span class="line">USART1 -&gt;CR1 &amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">15</span>);     <span class="comment">//16倍过采样</span></span><br><span class="line">USART1 -&gt;CR1 &amp;=~(<span class="number">3</span>&lt;&lt;<span class="number">11</span>);  <span class="comment">//字长和唤醒方式</span></span><br><span class="line">USART1 -&gt;CR1 &amp;=~(<span class="number">0X1F</span>&lt;&lt;<span class="number">4</span>); <span class="comment">//禁止中断</span></span><br><span class="line">USART1 -&gt;CR1 |=(<span class="number">0x1</span>&lt;&lt;<span class="number">13</span>);   <span class="comment">//使能usart</span></span><br><span class="line">USART1 -&gt;CR1 |=(<span class="number">0x3</span>&lt;&lt;<span class="number">2</span>);  <span class="comment">//接受使能和发送使能</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#160; &#160; &#160; &#160; 发送一个字节函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_byte</span><span class="params">(<span class="keyword">char</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!(USART1 -&gt;SR &amp;=(<span class="number">0x1</span>&lt;&lt;<span class="number">7</span>)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//等待发送移位寄存器为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USART1 -&gt;DR =data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#160; &#160;</p><p>&#160; &#160; &#160; &#160;发送字符串函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_str</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line">send_byte(*str++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#160; 接收一个字节函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">receive_byte</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">while</span>(!(USART1 -&gt;SR &amp;(<span class="number">0x1</span>&lt;&lt;<span class="number">5</span>)))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">data=USART1 -&gt;DR;</span><br><span class="line"><span class="keyword">return</span> data ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160; USART作为两个设备之间的一种通信协议，支持同步和异步两种通信方式。同步的时候两个设备需要共用同一个时钟，需要连接时钟线。异步的时候不用时钟连接线，通信双方按照设定好的波特率发送和接受数据即可。这里主要介绍一下UART异步通信方式。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="STM32" scheme="http://kerwang99.top/categories/STM32/"/>
    
    
      <category term="STM32" scheme="http://kerwang99.top/tags/STM32/"/>
    
      <category term="UART" scheme="http://kerwang99.top/tags/UART/"/>
    
  </entry>
  
  <entry>
    <title>Windows下搭建HEXO博客</title>
    <link href="http://kerwang99.top/2019/05/24/Windows%E4%B8%8B%E6%90%AD%E5%BB%BAHEXO%E5%8D%9A%E5%AE%A2/"/>
    <id>http://kerwang99.top/2019/05/24/Windows下搭建HEXO博客/</id>
    <published>2019-05-24T11:38:47.000Z</published>
    <updated>2019-05-26T03:27:47.965Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --><hr><blockquote><p><strong>前言</strong></p><p>最近呢出于一些好奇心和身边一些同学的影响，就想搭建一个自己的博客来玩玩。看到他们都有自己的个人博客，而且还很炫酷就很羡慕！<del>搭建个人博客的好处呢我就不多说了</del>（主要是为了装逼((#^.^#)）。那接下来呢我们就自己动手搭建一个博客来玩玩。OK，废话不多说直接开干。</p></blockquote><a id="more"></a><h1 id="一-博客搭建环境的准备"><a href="#一-博客搭建环境的准备" class="headerlink" title="一,博客搭建环境的准备"></a>一,博客搭建环境的准备</h1><h2 id="1，安装Node-js"><a href="#1，安装Node-js" class="headerlink" title="1，安装Node.js"></a>1，安装Node.js</h2><p>首先我们去Node.js的<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">官网下载</a> 软件进行安装，选择与自己操作系统对应的安装包即可。</p><p><img src="\images\1\node.png" alt></p><p>安装过程非常简单，不停地点NEXT就完事了。</p><h2 id="2，安装Git"><a href="#2，安装Git" class="headerlink" title="2，安装Git"></a>2，安装Git</h2><p>直接去Git官网根据自己的情况选择32位还是64位，直接<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">下载安装</a>。</p><p><img src="\images\1\git.png" alt></p><p>和上面安装一样，不停地下一步。(<em>这里为了在以后的使用过程中不出现一些未知错误，我们直接按照默认路径安装了。</em>)</p><p>安装结束后，我们可以在开始菜单下看到我们刚才安装的git。这个Git Bash有点类似于Linux下的终端。</p><p><img src="\images\1\批注 2019-05-25 204431.png" alt></p><p>##</p><h2 id="3，安装HEXO-博客框架"><a href="#3，安装HEXO-博客框架" class="headerlink" title="3，安装HEXO 博客框架"></a>3，安装HEXO 博客框架</h2><p>##</p><p>接下来我们在E盘下新建一个文件夹来存放博客生成的文件，就起名叫Myblog吧。进入新建的Mylog文件夹下在空白地方单击鼠标右键，选择Git Bash Here</p><p><img src="\images\1\批注 2019-05-25 205238.png" alt></p><p>进去后我们首先看看==node== 和包管理器 ==npm==安装好没。只要在命令行输入 <code>node -v</code>和<code>npm -v</code> 即可。看到如下图的版本号说明安装成功。</p><p><img src="\images\1\批注 2019-05-25 210157.png" alt></p><p>上面所做的都是铺垫工作，接下来我们真正的开始安装==hexo==博客框架。我们需要借助npm包管理器来安装我们的博客框架，由于国内的镜像源下载比减慢，所以我们利用npm安装一个淘宝的镜像源cnpm。</p><p>在终端输入</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g cnpm --registry=https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure><p>看到下图说明安装成功。</p><p><img src="\images\1\批注 2019-05-25 211941.png" alt></p><p>然后用cnpm安装HEXO博客框架。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><p>用<code>hexo -v</code>来验证hexo是否安装好</p><p><img src="\images\1\批注 2019-05-25 212953.png" alt></p><h1 id="二，搭建博客"><a href="#二，搭建博客" class="headerlink" title="二，搭建博客"></a>二，搭建博客</h1><h2 id="1，博客初始化"><a href="#1，博客初始化" class="headerlink" title="1，博客初始化"></a>1，博客初始化</h2><p>在正式搭建博客之前先查看我们的工作目录是否在Myblog下，放在一个文件夹下方便我们以后的管理。要是搭建过程中出现错误我们直接可以把Myblog这个文件夹干点，从来就OK。</p><p><img src="\images\1\批注 2019-05-25 213634.png" alt></p><p>可以看到当前工作目录正确。</p><p>用==hexo==生成博客</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure><p>看到如下已经说明博客生成成功。</p><p><img src="\images\1\批注 2019-05-25 214223.png" alt></p><h2 id="2，运行博客"><a href="#2，运行博客" class="headerlink" title="2，运行博客"></a>2，运行博客</h2><p>通过<code>hexo s</code>命令来启动博客</p><p><img src="\images\1\批注 2019-05-25 214642.png" alt></p><p>OK！本地博客已经启动完成了，我们可以通过 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 来访问查看一下我们的博客。</p><p>只要在浏览器输入 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可。（<u>这里我说一下我曾经踩过的坑吧，</u> <u>在用<code>hexo s</code> 命令来启动博客时出现错误。经查询原来是福昕PDF阅读器占用了4000这个端口。我们在启动博客时只需要使用命令 <code>hexo server -p 5000</code> 换个端口就可以。</u>）</p><p><img src="\images\1\批注 2019-05-25 215014.png" alt></p><p>可以看到系统默认给我们创建了一篇hello word的文章，本地博客已经搭建完成。接下来我们将本地博客部署到远端，通过远端来访问。</p><h1 id="三，部署博客到远端"><a href="#三，部署博客到远端" class="headerlink" title="三，部署博客到远端"></a>三，部署博客到远端</h1><p>博客你可以部署到自己的服务器上，也可以部署到一些第三方的代码托管平台。比如：github，conding等。这里我呢是把博客部署到github上，建议大家还是部署到conding上，github由于是国外平台访问起来很慢。部署到conding<a href="https://caiyantao.gitee.io/2019/04/13/Hexo%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="noopener">参考这篇文章</a> 。下面我将介绍如何部署到github上去。</p><h2 id="1，github账号的注册"><a href="#1，github账号的注册" class="headerlink" title="1，github账号的注册"></a>1，github账号的注册</h2><p>我们直接去github<a href="https://github.com/join" target="_blank" rel="noopener">官网上注册账号</a>，</p><p><img src="\images\1\批注 2019-05-26 092409.png" alt></p><p>直接按操作下一步就可以。账号创建完成后我们点击右上角的加号创建一个仓库，用来存放我们博客生成的文件。</p><p><img src="\images\1\批注 2019-05-26 093118.png" alt></p><p><img src="\images\1\批注 2019-05-26 093430.png" alt></p><p><strong>注意：这里需要注意你的仓库名称必须是你的<code>用户名,github.io</code> 比如我的用户名是contenn 那我的仓库名称就是contenn.github.io</strong></p><p>直接点击下面的创建仓库，创建步骤就完成了。现在仓库是空的，下面我们进行一些设置。</p><p><img src="\images\1\批注 2019-05-26 094705.png" alt></p><h2 id="2，部署的设置"><a href="#2，部署的设置" class="headerlink" title="2，部署的设置"></a>2，部署的设置</h2><p>首先呢我们需要在我们的博客目录下安装一下我们的部署插件。通过命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="keyword">install</span> <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure><p><img src="\images\1\批注 2019-05-26 095232.png" alt></p><p>然后在设置一个非常重要的文件，就是我们博客目录下面的站点配置文件==_config.yml==</p><p><img src="\images\1\批注 2019-05-26 095552.png" alt></p><p>可以用vim编辑器打开，也可以用notepad++来打开。</p><p><img src="\images\1\批注 2019-05-26 095759.png" alt></p><p>打开改文件后我们拉到最下面，在type: 后面加上git。<em>注意：git前面必须要有一个空格。</em></p><p><img src="\images\1\批注 2019-05-26 100233.png" alt></p><p>再在后面添加我们仓库的地址 ==repo：仓库地址== 同样需要注意冒号后面需要有空格</p><p><img src="\images\1\批注 2019-05-26 100655.png" alt></p><p>仓库的地址就是下图圈起来的那部分</p><p><img src="\images\1\批注 2019-05-26 100721.png" alt></p><p>在最后加上</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">branch: </span>master</span><br></pre></td></tr></table></figure><p>可以看到我们就修改了站点配置文件_config.yml文件中最后几行。</p><p><img src="\images\1\批注 2019-05-26 101229.png" alt></p><p>保存退出。</p><h2 id="3，部署到github"><a href="#3，部署到github" class="headerlink" title="3，部署到github"></a>3，部署到github</h2><p>部署非常简单，只需要输入命令</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure><p>部署成功后我们用 用户名.github.io就可以访问啦！</p><p>最后我们介绍几个常用的命令吧！</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">hexo init</td><td style="text-align:center">创建博客</td></tr><tr><td style="text-align:center">hexo server -p 5000</td><td style="text-align:center">端口被占用时换端口</td></tr><tr><td style="text-align:center">hexo cl</td><td style="text-align:center">清理缓存</td></tr><tr><td style="text-align:center">hexo s</td><td style="text-align:center">查看本地生成的博客</td></tr><tr><td style="text-align:center">hexo g</td><td style="text-align:center">生成博客</td></tr><tr><td style="text-align:center">hexo new 文章名</td><td style="text-align:center">创建一篇新的博客</td></tr></tbody></table><p>参考视频：<a href="https://www.bilibili.com/video/av44544186?t=1110" target="_blank" rel="noopener">https://www.bilibili.com/video/av44544186?t=1110</a></p><p>参考文章：<a href="https://blog.csdn.net/tonydandelion2014/article/details/61615898" target="_blank" rel="noopener">https://blog.csdn.net/tonydandelion2014/article/details/61615898</a></p><h1 id="四，博客的美化"><a href="#四，博客的美化" class="headerlink" title="四，博客的美化"></a>四，博客的美化</h1><p>博客的美化在这里就不说了，网上教程很多。大家可以在网上搜一搜。我这里主要参考了这篇文章的教程，感兴趣的朋友可以去看看。</p><p>参考文章：<a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">Hexo博客优化之Next主题美化</a></p><hr><p><strong>最后：</strong></p><p>在搭建博客过程中难免会遇到各种问题，遇到问题首先我们不要慌。先查看出问题的出错点在哪里，然后在再网上搜教程或者在别人博客底下留言找博主帮忙解决。切记不要什么都没弄明白在网上盲目问别人。比如：我们在用git部署过程中或者修改主题后出现的各种ERROR，我们要先看清楚错误出现在哪里，看自己能否解决，不要上来就截一张图拿给别人看。毕竟自己在解决问题的过程中也能学到好多知识。</p><p>其实博主也是比较懒的，一个博客搭建耗时两周才完成。加之这两周也是考试周，比较忙，在美化过程中也是各种出错，所以拖得时间也是比较久的。好歹没放弃，最终还是完成了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --&gt;&lt;hr&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;最近呢出于一些好奇心和身边一些同学的影响，就想搭建一个自己的博客来玩玩。看到他们都有自己的个人博客，而且还很炫酷就很羡慕！&lt;del&gt;搭建个人博客的好处呢我就不多说了&lt;/del&gt;（主要是为了装逼((#^.^#)）。那接下来呢我们就自己动手搭建一个博客来玩玩。OK，废话不多说直接开干。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HEXO博客" scheme="http://kerwang99.top/categories/HEXO%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="HEXO" scheme="http://kerwang99.top/tags/HEXO/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://kerwang99.top/2019/05/18/hello-world/"/>
    <id>http://kerwang99.top/2019/05/18/hello-world/</id>
    <published>2019-05-18T08:17:11.000Z</published>
    <updated>2019-05-26T03:29:48.427Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Jun 24 2019 21:51:31 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hex
      
    
    </summary>
    
    
      <category term="测试" scheme="http://kerwang99.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
